














[{"categories":null,"contents":"HPKE, published as RFC 9180, describes a scheme for hybrid public key encryption.\n ðŸ“š Please go and read our TL;DR on HPKE if you nee more background on HPKE.\n In this I describe the first executable HPKE specification using hacspec. It is not only an executable specification of HPKE, it is also an annotated version of the RFC that can be read instead of (or in addition to) the RFC. While the TL;DR on HPKE was intended for consumers or potential users of HPKE, this blog post is aimed at implementators that want to implement HPKE or understand it better.\nIt is a showcase for Cryspen\u0026rsquo;s technology stack. In a follow up blog post we will describe how to connect the hacspec specification to efficient cryptographic primitives and formal proofs.\nThis blog post focuses on the Base and Auth mode with DHKEM to demonstrate the capabilities of hacspec. For the full specification please read the full documentation, or look at the Github repository for the HPKE hacspec source code.\nRecall that HPKE provides a variant of public-key encryption of arbitrary-sized plaintexts for a recipient public key. It works for any combination of an asymmetric key encapsulation mechanism (KEM), key derivation function (KDF), and authenticated encryption with additional data (AEAD) encryption function.\nIn the following I\u0026rsquo;ll first show the high-level API of HPKE works before giving details on the core functions within HPKE. All code examples are in hacspec.\n ðŸ’¡ Go ahead and run the hacspec HPKE in the browser.\n Encrypting to a Public Key This is the most basic functionality HPKE offers; encrypting a payload to a public key. So how does this look on the outside?\nThe process consists of two steps. First a random shared_secret is generated that can be used for symmetric encryption with an AEAD, and an encapsulation that can be used by the receiver in combination with their private key to compute the same shared_secret. This function is denoted SetupBaseS below (because this is setting up the sender in the HPKE base mode). Note that the setup function expands the shared_secret to a key schedule that is used by the AEAD. More details in the Setup section. Then the shared_secret is used to encrypt the payload with an AEAD. This function is denoted AeadSeal below.\nlet (enc, (key, nonce, _, _)) = SetupBaseS(config, pkR, info, randomness)?; let cipher_text = AeadSeal(aead_id, \u0026amp;key, \u0026amp;nonce, aad, payload)?; The receiver gets cipher_text and enc that it can use to retrieve the payload.\nlet (key, nonce, _, _) = SetupBaseR(config, enc, skR, info)?; let payload = AeadOpen(aead, \u0026amp;key, \u0026amp;nonce, aad, ct)?; In the remainder of this blog post we\u0026rsquo;ll show how SetupBaseS is defined. For a description of the receiver please check out the documentation. We will not define AeadSeal and AeadOpen here as they follow the definition of RFC 5116.\n ðŸ’¡ Background on hacspec Syntax In case you are not familiar with hacspec (Rust) syntax, here are some short explainers to understand the hacspec code. The Question mark ?\nThe question mark ? at the end of most lines in the hacspec code is the way Rust performs error propagation. If the function that is called before the ? does not return an error result, the program continues as expected. But if the function returns an error, the function stops and returns with the error instead.\nThe Result Type\nhacspec (and Rust) uses a Result type such as Result\u0026lt;OkType, ErrorType\u0026gt; to return errors. In hacspec result types are often wrapped into type aliases. For example the SenderContextResult type in the code snippet for SetupBaseS below is a type alias for Result\u0026lt;(Encapsulation, KeySchedule), Error\u0026gt;. If the function is successful and we reach line 10, the function returns success, which is written as SenderContextResult::Ok(...).\n The Auth Mode In the Auth mode HPKE requires additional input to the Setup functions. The sender needs to provide their private key skS to authenticate themselves. The receiver uses the sender\u0026rsquo;s public key pkS in addition to authenticate the sender. The two functions are defined as follows.\nSetupAuthS(config, pkR:, info, skS, randomness); SetupAuthR(config, enc, skR, info, pkS); Setup In order to set up the KEM and key schedule the sender uses the following SetupBaseS function. Recall that the BaseS refers to the HPKE base mode and sender.\nThe function takes the receiver\u0026rsquo;s public key pkR and context information info (a sequence of bytes to bind the setup to a specific context). In addition we need to pass in the configuration that contains the mode as well as the algorithm identifiers for the KEM. Because hacspec can\u0026rsquo;t draw its own randomness, as explained below, it is passed in as well.\npub fn SetupBaseS(  configuration: HPKEConfig,  pkR: \u0026amp;HpkePublicKey,  info: \u0026amp;Info,  randomness: Randomness, ) -\u0026gt; SenderContextResult {  let (shared_secret, enc) = Encap(kem(configuration), pkR, randomness)?;  let key_schedule = KeySchedule(  config,  \u0026amp;shared_secret,  info,  \u0026amp;default_psk(),  \u0026amp;default_psk_id(),  )?;  SenderContextResult::Ok((enc, key_schedule)) } For comparison you can find the RFC pseudocode definition of SetupBaseS below (which is not well defined as is because it is missing the algorithm identifiers). The main difference between the two functions is the explicit configuration and randomness required in hacspec.\ndef SetupBaseS(pkR, info):  shared_secret, enc = Encap(pkR)  return enc, KeyScheduleS(mode_base, shared_secret, info,  default_psk, default_psk_id) The setup function calls the two functions Encap and KeySchedule.\nEncap (Reminder: For demonstration purposes we use the DHKEM defined in the RFC.)\nThe Encap function takes the receiver\u0026rsquo;s public key pkR and generates a shared_secret as well as an encapsulation.\nIt is necessary to pass in the algorithm identifier to know which KEM to use and the randomness to generate a new ephemeral key pair for the KEM. See the discussion section below on the necessity of the API changes. Because the function can fail it returns a result instead of simply the computed values as described in the RFC pseudocode.\ndef Encap(pkR):  skE, pkE = GenerateKeyPair()  dh = DH(skE, pkR)  enc = SerializePublicKey(pkE)   pkRm = SerializePublicKey(pkR)  kem_context = concat(enc, pkRm)   shared_secret = ExtractAndExpand(dh, kem_context)  return shared_secret, enc All these changes make it much clearer what can happen within the function and in particular which error states might occur.\nThe Encap function generates a fresh DH key pair and computes the DH between the receivers public key and the ephemeral private key $\\text{dh}=\\text{skE}*\\text{pkR}$. The shared_secret is then computed as the output of a key derivation function (HKDF) on input of the dh value and the context that binds the key derivation to the parameters and public values. The encapsulation enc is the serialized public key pkE generated in the first step.\npub fn Encap(pkR: \u0026amp;PublicKey, alg: KEM, rand: Randomness) -\u0026gt; EncapResult {  let (skE, pkE) = GenerateKeyPair(alg, rand)?;  let dh = DH(alg, \u0026amp;skE, pkR)?;  let encapsulation = SerializePublicKey(alg, \u0026amp;pkE)?;   let pkRm = SerializePublicKey(alg, pkR)?;  let kem_context = enc.concat(\u0026amp;pkRm);   let shared_secret = ExtractAndExpand(alg, \u0026amp;suite_id(alg), dh, kem_context)?;  EncapResult::Ok((shared_secret, encapsulation)) } KeySchedule In order to use the shared_secret with an AEAD and allow exporting additional key material, the following KeySchedule derives the key and base_nonce for the AEAD and an exporter_secret to export other keys. The key schedule is essentially a series of HKDF calls to extract different keys from the shared secret.\nThe main difference to the RFC here is again that it is necessary to pass in algorithm identifiers and the suite_id to LabeledExtract and LabeledExpand. The suite_id binds the KDF extract and expand functions to the specific context and is implicit in the RFC.\npub fn KeySchedule(  config: HPKEConfig,  shared_secret: \u0026amp;SharedSecret,  info: \u0026amp;Info,  psk: \u0026amp;Psk,  psk_id: \u0026amp;PskId, ) -\u0026gt; ContextResult {  VerifyPSKInputs(config, psk, psk_id)?;  let HPKEConfig(mode, _kem, kdf, aead) = config;   let psk_id_hash = LabeledExtract(  kdf,  \u0026amp;suite_id(config),  \u0026amp;empty_bytes(),  \u0026amp;psk_id_hash_label(),  psk_id,  )?;  let info_hash = LabeledExtract(  kdf,  \u0026amp;suite_id(config),  \u0026amp;empty_bytes(),  \u0026amp;info_hash_label(),  info,  )?;  let key_schedule_context = hpke_mode_label(mode)  .concat_owned(psk_id_hash)  .concat_owned(info_hash);   let secret = LabeledExtract(kdf, \u0026amp;suite_id(config), shared_secret, \u0026amp;secret_label(), psk)?;   let key = LabeledExpand(  kdf,  \u0026amp;suite_id(config),  \u0026amp;secret,  \u0026amp;key_label(),  \u0026amp;key_schedule_context,  Nk(aead),  )?;  let base_nonce = LabeledExpand(  kdf,  \u0026amp;suite_id(config),  \u0026amp;secret,  \u0026amp;base_nonce_label(),  \u0026amp;key_schedule_context,  Nn(aead),  )?;  let exporter_secret = LabeledExpand(  kdf,  \u0026amp;suite_id(config),  \u0026amp;secret,  \u0026amp;exp_label(),  \u0026amp;key_schedule_context,  Nh(kdf),  )?; } For comparison you can find the RFC pseudocode definition of KeySchedule below. Note that the significantly longer hacspec definition above is not in fact longer but has longer lines that are wrapped.\ndef KeySchedule\u0026lt;ROLE\u0026gt;(mode, shared_secret, info, psk, psk_id):  VerifyPSKInputs(mode, psk, psk_id)   psk_id_hash = LabeledExtract(\u0026#34;\u0026#34;, \u0026#34;psk_id_hash\u0026#34;, psk_id)  info_hash = LabeledExtract(\u0026#34;\u0026#34;, \u0026#34;info_hash\u0026#34;, info)  key_schedule_context = concat(mode, psk_id_hash, info_hash)   secret = LabeledExtract(shared_secret, \u0026#34;secret\u0026#34;, psk)   key = LabeledExpand(secret, \u0026#34;key\u0026#34;, key_schedule_context, Nk)  base_nonce = LabeledExpand(secret, \u0026#34;base_nonce\u0026#34;, key_schedule_context, Nn)  exporter_secret = LabeledExpand(secret, \u0026#34;exp\u0026#34;, key_schedule_context, Nh)   return Context\u0026lt;ROLE\u0026gt;(key, base_nonce, 0, exporter_secret) This is all that is needed to implement HPKE. All code examples here are taken directly from the Cryspen HPKE reference implementation. You can find the full code in the Github repository as well as the documentation.\nImplementation Considerations When defining HPKE in hacspec, or most other programming languages, there are a number of considerations that impact the way the code looks.\nThe hacspec code is as close to the RFC pseudocode as possible. But some changes are needed.\nRandomness hacspec does not allow to draw randomness. It is therefore necessary to pass in randomness every time it is needed.\nThis approach is pretty close to the way this would be implemented in native Rust where a random-number generator is passed in and used to generate randomness. For simplicity hacspec expects the randomness to be drawn on the outside instead of doing it within the specification.\nNote that it is possible to pre-determine the amount of randomness needed by HPKE calls because randomness is only needed when setting up the sender. At this point the KEM mechanisms and hence the required randomness is known.\nConfiguration Parameters The HPKE RFC makes most of the configuration implicit to the functions rather than passing the algorithm identifiers around. Because the hacspec implementation has to know which algorithm to pick, this is of course not possible here.\nHPKE hacspec functions take either an HPKEConfig object with all algorithms in it or the specific algorithm identifier needed for the operation.\nNaming The HPKE RFC uses, in some cases, names that are impossible to use in hacspec because they are keywords or contain illegal characters. Further does hacspec not support member functions as defined for the Context.\nWe therefore replace . in member function calls such as Context.Export with an underscore, i.e. write Context_Export. Keywords such as open are replaced with a semantically equivalent version, i.e. HpkeOpen in this example.\nSecret bytes hacspec has the notion of secret integers that can\u0026rsquo;t be used for certain operations and should enforce secret-independent computation time.\nFor simplicity the hacspec HPKE implementation uses secret bytes everywhere even if not necessary, e.g. for cipher texts.\nErrors While the RFC defines a set of errors it does not always define which errors are raised. For example, it leaves open whether implementations convert errors from the Diffie-Hellman operations into KEM errors (EncapError/DecapError) or not.\nWith the specific implementation in hacspec here the errors are clearly defined.\nAbout hacspec hacspec is a specification language for cryptographic mechanisms, and more, embedded in Rust. It is a language for writing succinct, executable, formal specifications for cryptographic components. Syntactically, hacspec is a purely functional subset of Rust that aims to be readable by developers, cryptographers, and verification experts. An application developer can use hacspec to specify and prototype cryptographic components in Rust, and then either replace this specification with a verified implementation before deployment or use the hacspec code directly.\nWe used hacspec here to write an executable, succinct, specification of HPKE that\u0026rsquo;s embedding the full RFC into its documentation\nhacspec is at the heart of a novel, modular verification framework for Rust applications developed by Cryspen in cooperation with the Prosecco team.\nSummary Even though HPKE is a relatively simple scheme it requires care when implementing. This blog post gives an overview of how hacspec can be used to achieve an executable version of the HPKE RFC that can be used as implementation on its own or as specification and reference implementation when implementing HPKE.\nCryspen offers support for using HPKE as well as high assurance implementations of HPKE and other protocols. Get in touch for more information.\n   Github repository  Documentation  RFC  ","date":"24 Feb, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/hpke_spec_hu4cb9b0bb4d1bfca6e45e87162bd8ddf2_355178_545x0_resize_q95_h2_box_3.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/hpke_spec_hu4cb9b0bb4d1bfca6e45e87162bd8ddf2_355178_600x0_resize_q95_h2_box_3.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/hpke_spec_hu4cb9b0bb4d1bfca6e45e87162bd8ddf2_355178_700x0_resize_q95_h2_box_3.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/hpke_spec_hu4cb9b0bb4d1bfca6e45e87162bd8ddf2_355178_1110x0_resize_q95_h2_box_3.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/hpke_spec_hu4cb9b0bb4d1bfca6e45e87162bd8ddf2_355178_1110x0_resize_box_3.png\" alt=\"\" width=\"1229\" height=\"908\"\u003e\n\u003c/picture\u003e\n \n \n \n\n","permalink":"https://blog.cryspen.com/blog/hpke_spec/","tags":["hacspec","HPKE","IETF"],"title":"An Executable HPKE Specification"},{"categories":null,"contents":"HPKE is a CFRG in RFC 9180 that describes a scheme for hybrid public key encryption. It is co-authored by my Cryspen co-founder Karthikeyan Bhargavan and one of his PhD students Benjamin Lipp as part of his research at Inria.\nThis blog post will give a brief overview of the specification and describes some use cases.\nIf you want to learn more about the security proofs behind HPKE and the RFC process, Benjamin wrote an excellent blog post about it.\nHybrid Public Key Encryption, or short HPKE, is a cyrptographic mechanism that allows encrypting payload to a public key. It is called \u0026ldquo;hybrid\u0026rdquo; because the payload is encrypted with a symmetric scheme. The symmetric key is then encrypted to the receivers public key. The HPKE standard defines a number of natural extensions to the basic setting that allow the sender to authenticate themselves.\nHybrid Crypto Systems Hybrid public key encryption has been used in different ways since the early 1990s in protocols such as PGP or SMIME. While these two protocols are for a very specific use case a more general version of hybrid encryption is described in ECIES. ECIES is part of many systems nowadays. Storing keys in the secure enclave on an iOS device for example uses ECIES. For a deeper explanation and history of hybrid crypto systems I recommend reading Christopher Wood\u0026rsquo;s blog post.\nHowever, there\u0026rsquo;s no general description of hybrid public key encryption with modern primitives. The HPKE standard solves this issue. Even before the RFC is finalised it is used in specifications for ECH, MLS, ODOH, and PPM. This shows the high demand for HPKE.\nHPKE has four distinct modes of operation: Base, Auth, PSK, AuthPSK. In this blog post we only describe the two most commonly used modes Base and Auth.\nHPKE Modes\nThe Base mode is the most common use case for HPKE where payload is encrypted to a public key. All other modes are authenticated in different ways.\n Auth uses the sender\u0026rsquo;s private key for authentication PSK uses a pre-shared, high-entropy, key for authentication AuthPSK uses the sender\u0026rsquo;s private key as well as a pre-shared, high-entropy, key for authentication  Encrypting to a public key The following figure depicts the general flow of encrypting to a public key. This is the Base mode in HPKE. This is the most basic application of hybrid crypto systems. Alex knows the public key from Sasha and wants to send some Data to them. Shasha\u0026rsquo;s public key is used to encrypt a shared secret, which is used to encrypt the Data. The encrypted shared secret as well as the encrypted data is sent to Sasha, who can retrieve the shared secret with their corresponding private key.\nEncrypting to a public key \u0026amp; Authenticating with an asymmetric key Sometimes it is useful or necessary to authenticate the sender of the data. This is depicted in the figure below and represents the HPKE Auth mode. The authentication is achieved by mixing in the sender\u0026rsquo;s private key such that the receiver will only retrieve the correct shared secret if the public key they use for the sender corresponds to the used private key.\nHPKE HPKE is essentially standardising how to use Key Encapsulation Mechanisms (KEM) for hybrid encryption. The sender in HPKE uses a KEM to generate the shared secret as well as the encapsulation. The shared secret is then used in an AEAD (after running it through a key schedule) in order to encrypt a payload.\nAll HPKE use cases so far only take advantage of the single-shot APIs from HPKE. In order to encrypt a payload to a public key the sender needs to provide the receiver\u0026rsquo;s public key pkR, some information info and additional data aad to bind the encryption to a certain context, as well as the payload pt. HPKE returns the cipher text ct as well as the encapsulation enc that are both sent to the receiver.\nenc, ct \u0026lt;- Seal(pkR, info, aad, pt) When using the Auth mode the sender\u0026rsquo;s private key sk is needed in addition.\nThe receiver takes the encapsulation enc and cipher text ct together with their private key to retrieve the payload.\npt \u0026lt;- Open(enc, skR, info, aad, ct) When using the Auth mode the sender\u0026rsquo;s public key pkS is needed in addition.\nMultiple Encryptions HPKE allows multiple encryptions with the same shared secret. This is favourable if multiple messages are sent from the sender to the receiver. To this end HPKE generates a context that allows encrypting (and decrypting) multiple messages.\nenc, ContextS \u0026lt;- SetupS(pkR, info) ContextR \u0026lt;- SetupR(enc, skR, info) Note that HPKE goes a step further than the AEAD RFC and simplifies the API. The consumer only needs to provide the payload and (potentially empty) additional data. HPKE takes care of providing unique nonces to the AEAD and fails if the maximum number of encryptions with the context have been performed \u0026mdash; in particular if the nonce would overflow.\nct \u0026lt;- ContextS.Seal(aad, pt) pt \u0026lt;- ContextR.Open(aad, ct) Exporting Secrets In some scenarios applications need to establish additional shared secrets. This can be achieved with the HPKE exporter interface. The API is similar to the Seal and Open functions above but don\u0026rsquo;t require a payload or additional data. Instead an exporter_context and the length of the exported secret L have to be provided.\nenc, exported_secret \u0026lt;- SendExport(pkR, info, exporter_context, L) exported_secret \u0026lt;- ReceiveExport(enc, skR, info, exporter_context, L) Use Cases Instead of inventing new use cases for HPKE we describe how HPKE is used in MLS and ECH as they reflect common uses of hybrid public key encryption.\nHPKE in MLS MLS (Message Layer Security) is an IETF draft that standardises a new way of efficiently encrypting messages between participants in groups. It aims to solve the problem of end-to-end encryption in instant messaging. HPKE is a core building block. In order to encrypt a message to a specific entity in the protocol, MLS uses HPKE to encrypt the message to the specific public key.\nHPKE in ECH ECH (Encrypted Client Hello) is a mechanism in TLS (Transport Layer Security) for encrypting a ClientHello message under a server public key. This description from the ECH draft corresponds directly to the Base mode of HPKE as described above. This allows TLS connections to become more private because they don\u0026rsquo;t leak information about the connection, in particular the exact server the client wants to connect to.\nDemo In order to better understand the message flow and working of HPKE we put together an interactive demo below to demonstrate how HPKE works.\n First generate a key pair for the receiver. Then populate the info, additional data, and payload fields on the sender side. When clicking the \u0026ldquo;HPKE Seal\u0026rdquo; button on the sender the following happens   The sender retrieves the public key from the receiver that has been generated in the first step. The sender uses HPKE to encrypt the payload together with the info and additional data to the receiver\u0026rsquo;s public key. The result is written into the Encoded Shared Secret and Ciphertext fields.  When clicking \u0026ldquo;HPKE Open\u0026rdquo; the receiver uses the private key to retrieve the shared secret and decrypt the ciphertext. The \u0026ldquo;Info\u0026rdquo; and \u0026ldquo;Additional Data\u0026rdquo; are the same as entered on the sender\u0026rsquo;s side.  Try it out now!  The demo is written in hacspec (a subset of Rust) with a WASM frontend. Please stay tuned for a follow-up blog post diving into the details of this implementation.\nSummary HPKE is a simple, but very powerful new tool that allows to efficiently solve key distribution problems (see the MLS use case) as well as increase privacy in existing protocols (see the ECH use case).\nCryspen offers support for using HPKE as well as high assurance implementations of HPKE and other protocols. Get in touch for more information.\n","date":"24 Feb, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/tldr-hpke_hu08cb25aae405155d9080e0a0f66756a3_268000_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/tldr-hpke_hu08cb25aae405155d9080e0a0f66756a3_268000_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/tldr-hpke_hu08cb25aae405155d9080e0a0f66756a3_268000_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/tldr-hpke_hu08cb25aae405155d9080e0a0f66756a3_268000_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/tldr-hpke_hu08cb25aae405155d9080e0a0f66756a3_268000_1110x0_resize_q95_box.jpg\" alt=\"\" width=\"2221\" height=\"1293\"\u003e\n\u003c/picture\u003e\n \n \n \n\n","permalink":"https://blog.cryspen.com/blog/tldr-hpke/","tags":["tl;dr","HPKE","IETF"],"title":"TL;DR - Hybrid Public Key Encryption"},{"categories":null,"contents":"Cryspen co-founder Karthik Bhargavan got awarded an ERC Proof of Concept grant for commercialising the know-how and landmark research results from his Inria research group PROSECCO through Cryspen.\nAnnouncement Cryptographic mechanisms are crucial to the security of our digital lives but their design and implementation remains notoriously difficult and error-prone. With the help of two ERC Grants, Karthikeyan Bhargavan and the Prosecco team at Inria have developed state-of-the-art formal verification techniques that can be applied to real-world cryptographic software. In particular, they used these techniques to help design and analyze the TLS 1.3 protocol standard, as well to build the HACL* verified cryptographic library, code from which has been incorporated in mainstream software projects including Mozilla Firefox, the Linux Kernel, the Tezos Blockchain, the WireGuard VPN, and the ElectionGuard voting system.\nThe goal of this new ERC Proof of Concept grant is to build upon these these landmark research results and to commercialise the associated know-how through a new company called Cryspen. Cryspen will build a verified cryptographic software stack and an associated verification toolchain that is well-documented and easy to use for security developers. Cryspen will offer consulting and support contracts for this stack as well as software contracts for developing new cryptographic applications, ranging from secure messaging system to privacy-preserving machine learning.\nCryspen is co-founded by Franziskus Kiefer (CEO), Karthikeyan Bhargavan, and Jonathan Protzenko. For more information, email info@cryspen.com\n","date":"10 Feb, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/erc-cover_hueebb7cb7b7d5f8212f38a9f8abb74d19_57629_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/erc-cover_hueebb7cb7b7d5f8212f38a9f8abb74d19_57629_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/erc-cover_hueebb7cb7b7d5f8212f38a9f8abb74d19_57629_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/erc-cover_hueebb7cb7b7d5f8212f38a9f8abb74d19_57629_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/erc-cover_hueebb7cb7b7d5f8212f38a9f8abb74d19_57629_1110x0_resize_q95_box.jpg\" alt=\"\" width=\"1200\" height=\"849\"\u003e\n\u003c/picture\u003e\n \n \n \n\n","permalink":"https://blog.cryspen.com/blog/erc-poc/","tags":["ERC","grant"],"title":"Cryspen ERC PoC Grant"}]