





























[{"categories":null,"contents":"We have joined forces with our friends from Phoenix R\u0026amp;D to improve OpenMLS.\nThe MLS protocol draft is in the IETF working group\u0026rsquo;s last call and is thus on track to become an RFC soon. We want to make sure that OpenMLS is ready for wider adoption by the time the RFC is ready. To achieve this we start by catching up with all the changes to the protocol (up to the current draft-16), improving test coverage of the code, and working towards a more comprehensive test framework for interoperability.\nThis is part of Cryspen\u0026rsquo;s larger effort to make end-to-end encryption ubiquitous in any application. Cryspen is also working on formalising and extending MLS to be usable in many more scenarios as well as a formally verified implementation all variants. The results will make it easy for any application to use end-to-end encryption.\nWe want to thank the Sovereign Tech Fund for funding OpenMLS as the first project in its pilot round.\nPlease get in touch if you have any questions about key management, encryption, or MLS and OpenMLS.\n","date":"19 Oct, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/openmls_hu3d03a01dcc18bc5be0e67db3d8d209a6_553773_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/openmls_hu3d03a01dcc18bc5be0e67db3d8d209a6_553773_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/openmls_hu3d03a01dcc18bc5be0e67db3d8d209a6_553773_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/openmls_hu3d03a01dcc18bc5be0e67db3d8d209a6_553773_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/openmls_hu3d03a01dcc18bc5be0e67db3d8d209a6_553773_1110x0_resize_q95_box.jpeg\" alt=\"\" width=\"1920\" height=\"1440\"\u003e\n\u003c/picture\u003e\n \n \n \n\n","permalink":"https://blog.cryspen.com/blog/hello-openmls/","tags":["MLS","OpenMLS","IETF"],"title":"OpenMLS"},{"categories":null,"contents":"Earlier this year, Tezos and Nomadic Labs started to work with Cryspen to improve HACL* and ensure that it is a viable long-term solution for Tezos' cryptographic needs. HACL is a set of high assurance cryptographic primitives used by Tezos for most of its cryptography.\nThe original HACL* has been developed as part of Project Everest and is a collection of high-assurance cryptographic algorithms. Its source is written in F*, which is used to generate C code. It also contains verified assembly code from the Vale project and an agile multiplexed cryptographic provider called EverCrypt.\nTo ensure the long-term viability of the software, Cryspen is building a usable cryptography library based on the research artefacts from HACL*. The new library lives in the new hacl-packages repository, where several cryptographic packages are developed by Cryspen. In particular, it contains a portable C crypto library that selects optimised implementations for each platform and Rust, OCaml, and JavaScript bindings for this library.\nTo increase the usability and performance of the library, Cryspen is also in the process of improving some algorithms, adding more usable APIs, and writing documentation.\nWe reached the first milestone for the HACL transition by providing a library that is easy to build and use on all major platforms and operating systems.\nThe library is still a work in progress, and especially the bindings for other languages such as OCaml, Rust, and JavaScript have not all been moved or finished yet. But we think this is a good point to let everyone know we\u0026rsquo;re working on this project and that the library can be used now.\nIf you use cryptography anywhere, we\u0026rsquo;d be happy if you used HACL and told us if it\u0026rsquo;s working for you or (why) not.\nPlease get in touch if you have any questions about high assurance cryptography or the HACL library in particular.\nIf you want to learn more about HACL and previous efforts around the library in the Tezos ecosystem, there\u0026rsquo;s a great blog post by Victor from Nomadic Labs.\n","date":"07 Jun, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/boxes_hu8443006d88e3da9a43f051f00aa825dd_384728_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/boxes_hu8443006d88e3da9a43f051f00aa825dd_384728_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/boxes_hu8443006d88e3da9a43f051f00aa825dd_384728_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/boxes_hu8443006d88e3da9a43f051f00aa825dd_384728_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/boxes_hu8443006d88e3da9a43f051f00aa825dd_384728_1110x0_resize_q95_box.jpg\" alt=\"\" width=\"2000\" height=\"1333\"\u003e\n\u003c/picture\u003e\n \n \n \n\n","permalink":"https://blog.cryspen.com/blog/introducing-hacl-packages/","tags":["HACL"],"title":"Introducing HACL Packages"},{"categories":null,"contents":"Cryspen builds high assurance cryptography. But what does this actually mean?\nBefore focusing on cryptography it is interesting to look at high assurance software in general. How is high assurance software different from other software?\nHigh assurance software is usually seen as being more trustworthy than other software. This is especially interesting in high-risk/high-stakes environments such as financial institutions or governments. There are different ways to achieve better guarantees for software. Today the most commonly used technique to increase trust into software is using certifications like common criteria or FIPS. While these certifications offer a certain level of additional guarantees, only the highest levels require some form of formal verification of the production source code. As such certification usually reaches only up to a certain level of high assurance.\nInstead, using formal methods to increase trust in software offers real tangible guarantees on a software artifact. But in order to get actual guarantees we have to define the properties that are guaranteed and put it into perspective by defining different assurance levels. Before doing this we look at the different techniques used in high assurance software engineering.\nTechniques There are a number of different techniques used in (high assurance) software engineering. Some are simply good engineering practice while others go beyond what is done for most software. The following picture gives a high-level overview of the different techniques. (The list is of course not exhaustive and some grouping might be arbitrary.)\nOn the left side we have safe programming languages and engineering processes that are the bedrock of high assurance software engineering. Processes ensure that the development and maintenance process is safe while using a safe programming language such as Rust that gives memory safety guarantees provides a safety baseline for the software.\nThe engineering infrastructure in the center is used to enforce policies and link everything together. It is the glue that implements engineering processes and ensures safe operations of the code at all times. On the right hand side we have engineering practices divided into dynamic and static tools, or testing and formal methods. There are a lot of different testing techniques from fuzzing to known answer tests that ensure that the code is operating correctly and safely for a certain set of inputs. With static analysis and formal methods we can go a step further and ensure that the code is correct and safe for all inputs.\nAssurance Levels Speaking about ‚Äúhigh assurance‚Äù is so vague that it can be considered meaningless. When speaking about high assurance software it is paramount to define a set of properties the software guarantees. To this end we define a set of assurance levels a software artifact can achieve and a set of techniques used to get there. The following picture sorts the previously defined techniques according to the level of assurance they provide and the complexity required to use them.\nCA-1 The first level of high assurance software is what I‚Äôd flippantly call ‚Äúwell written software‚Äù. At this level no complex tools are required. Instead good engineering principles are applied.\nNote that this level must not be used for cryptographic software. Cryptography requires at least CA-2.\nThe programming language and how it is used is the first important point. A programming language like Rust that is memory safe and has a lot of additional features that allow to ensure that the code is ‚Äúsafe‚Äù is paramount. It is well known that memory safety is the root cause for most security issues with about 70% (see what Google, Microsoft, or the ISRG say about this). They are only possible because languages like C and C++ are not memory safe.\nThe code requires a sufficient amount of tests. It is difficult and arbitrary to define an exact number for test coverage. But I think it is safe to say that a test coverage of less than 70% is not acceptable. Defining test coverage, quantitatively and qualitatively, is part of the engineering process.\nBecause testing against itself is not sufficient, test vectors with known answer tests must be used. If the implementation does not have a generally accepted specification or (de-facto) reference implementation that can be used to get test vectors, a reference implementation (specification) must be written to produce test vectors.\nEngineering processes must be implemented that ensure that the code can be safely maintained in the long-run. An engineering infrastructure must be in place to enforce processes and help the engineering process.\nProperties:\nMemory safety Adequate test coverage Known answer tests Engineering best practices Review guidelines Continuous integration Documentation (Security) bug reporting Release management CA-2 The second level includes everything from the first level but adds properties specific to cryptographic code and more advanced testing methods.\nIn cryptographic code it is important that no decisions are made based on secret information. It is therefore necessary to avoid any branching on secret data or memory access based on secret data. There is research tooling out there that tries to ensure this and a lot of good practices to avoid it. But there‚Äôs no comprehensive way of doing this right now. With Cryspen we develop a set of tools to ensure secret independent computation that we use and maintain.\nOn this level more advanced testing such as fuzzing and property based testing is required as well to make sure that the code is not only safe in well defined states but can handle any input.\nProperties:\nSecret independent computation No secret-dependent branching No secret-dependent memory access Advanced testing Fuzzing Sanitizer builds Property based testing CA-2+ The secret independent computation properties in CA-2 can be shown on different levels. Often this is done only on the programming language level rather than the machine code. If the secret independent computation is ensured on the machine code level, we call this CA-2+. Higher levels are augmented with the + in the same way if the secret independence is given after compilation.\nProperties:\nSecret independent computation ensured on the machine code level CA-3a The third assurance level includes the first two but requires formal methods. This is what we will always aim for. But because of the complexity and real world constraints it is not always feasible to achieve this level for all code.\nCryptographic primitives are one building block used to build cryptographic protocols. Because they require highly efficient implementations but usually have a rather succinct mathematical definition, functional and semantic correctness are the properties we are interested in. In particular, the efficient implementation of a cryptographic primitive must be shown equivalent to a self-evidently correct specification. Additionally semantic properties such as ‚Äúdecryption is the inverse of encryption‚Äù can be shown. The exact properties proven must be clearly stated for every artifact.\nData structures and other building blocks are needed to build cryptographic protocols in addition to the primitives. They must be similarly shown to be correct and safe to use by using functional and semantic correctness proofs.\nOn this level the cryptographic protocols themselves are written in a succinct way such that they can be inspected by hand and compared to a general specification if available.\nProperties:\nFunctional and semantic security proofs CA-3b The third level can be extended to require formal proofs on the protocol layer. While cryptographic protocols can often be written in a way that they are self-evidently correct and efficient, this is not enough if the protocol is not standardized or is too complex to inspect manually.\nSecurity models and properties are defined for a protocol and they are proven on the implementation of the cryptographic protocols using formal methods. These properties are very specific to each protocol and can range from the correctness of a state machine to the security against a certain type of attacker.\nProperties:\nSecurity proofs High-Assurance? https://highassurance.rs has some great documentation on writing good Rust code. However, it also has a good example of what I don‚Äôt consider high assurance software and exemplifies why it is so important to specify all claims precisely instead of simply claiming high assurance. (Note that this is just an example to show why it is so important to exactly specify what assurances are given. This is not supposed to bash the https://highassurance.rs folks. I think it\u0026rsquo;s a great effort.)\nLet‚Äôs take a look at chapters 2.4-2.6 that describe a high assurance implementation of the RC4 stream cipher. At the end of the section the authors state the following:\nYou\u0026rsquo;ve now built your first piece of high assurance software (sans the RC4 algorithm itself). Your RC4 library is:\nFully memory-safe, hence #![forbid(unsafe_code)] Stand-alone and capable for running almost anywhere, hence #![no_std] Functionally validated, using official IETF test vectors While these points are all on the list above they are what I would consider good engineering principles (known answer tests with test vectors, and memory safety). In particular, they lay the foundation for high assurance software but don‚Äôt constitute high assurance in itself. As is, the code itself would be CA-1 but additional mechanisms in the form of engineering processes and infrastructure are needed for full CA-1 compliance. (Similar additional mechanisms are mentioned in Chapter 2.)\nHowever, CA-1 is not sufficient for cryptographic primitives as stated above. To reach CA-2 the code needs to be rewritten though because it has secret dependent memory access. After doing this property based testing, fuzzing, and techniques ensuring secret independent computation have to be added.\nBecause the code can be seen as a spec one can argue that it reaches CA-3a now as well. CA-3b is not applicable. However it is not very efficient but rather a specification. In order to use the algorithm in a real application one might want to implement an efficient version that would then require an equivalence proof with the specification.\nRC4 itself is of course not secure and must not be used! This is just taking the example from https://highassurance.rs.\nCryspen High Assurance Cryptography At Cryspen we consider CA-1 regular software. Cryptographic code at Cryspen must always be CA-2 or higher.\nWe are working on different high assurance cryptographic primitives and protocols right now.\nHACL The HACL packages wrap the HACL* research artifacts and constitute a high assurance cryptographic library. The library is CA-3a because it is proven to be memory safe, has correctness proofs with respect to a specification and ensures secret independent computation on a programming language level.\nHPKE The HPKE implementation is a specification of the HPKE RFC and as such is CA-3a because it is self-evidently correct as a specification and uses formally verified cryptography with CA-3a. In a next step the HPKE implementation will be connected to the Cryptoverif models to prove security properties and thus reach the highest assurance level CA-3b.\nTLS 1.3 In an NGI Assure project we develop the first formally verified, production ready TLS 1.3 implementation.\nCryspen offers high assurance cryptographic implementations. Get in touch for more information.\n","date":"02 May, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/high-assurance-cryptography-1_hu3d03a01dcc18bc5be0e67db3d8d209a6_551395_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/high-assurance-cryptography-1_hu3d03a01dcc18bc5be0e67db3d8d209a6_551395_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/high-assurance-cryptography-1_hu3d03a01dcc18bc5be0e67db3d8d209a6_551395_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/high-assurance-cryptography-1_hu3d03a01dcc18bc5be0e67db3d8d209a6_551395_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/high-assurance-cryptography-1_hu3d03a01dcc18bc5be0e67db3d8d209a6_551395_1110x0_resize_q95_box.jpg\" alt=\"\" width=\"1920\" height=\"1280\"\u003e\n\u003c/picture\u003e\n \n \n \n\n","permalink":"https://blog.cryspen.com/blog/high-assurance-cryptography-1/","tags":["High Assurance","Engineering","Formal Methods"],"title":"What is High Assurance Cryptography?"},{"categories":null,"contents":"HPKE, published as RFC 9180, describes a scheme for hybrid public key encryption.\nüìö Please go and read our TL;DR on HPKE if you nee more background on HPKE.\nIn this I describe the first executable HPKE specification using hacspec. It is not only an executable specification of HPKE, it is also an annotated version of the RFC that can be read instead of (or in addition to) the RFC. While the TL;DR on HPKE was intended for consumers or potential users of HPKE, this blog post is aimed at implementators that want to implement HPKE or understand it better.\nIt is a showcase for Cryspen\u0026rsquo;s technology stack. In a follow up blog post we will describe how to connect the hacspec specification to efficient cryptographic primitives and formal proofs.\nThis blog post focuses on the Base and Auth mode with DHKEM to demonstrate the capabilities of hacspec. For the full specification please read the full documentation, or look at the Github repository for the HPKE hacspec source code.\nRecall that HPKE provides a variant of public-key encryption of arbitrary-sized plaintexts for a recipient public key. It works for any combination of an asymmetric key encapsulation mechanism (KEM), key derivation function (KDF), and authenticated encryption with additional data (AEAD) encryption function.\nIn the following I\u0026rsquo;ll first show the high-level API of HPKE works before giving details on the core functions within HPKE. All code examples are in hacspec.\nüí° Go ahead and run the hacspec HPKE in the browser.\nEncrypting to a Public Key This is the most basic functionality HPKE offers; encrypting a payload to a public key. So how does this look on the outside?\nThe process consists of two steps. First a random shared_secret is generated that can be used for symmetric encryption with an AEAD, and an encapsulation that can be used by the receiver in combination with their private key to compute the same shared_secret. This function is denoted SetupBaseS below (because this is setting up the sender in the HPKE base mode). Note that the setup function expands the shared_secret to a key schedule that is used by the AEAD. More details in the Setup section. Then the shared_secret is used to encrypt the payload with an AEAD. This function is denoted AeadSeal below.\nlet (enc, (key, nonce, _, _)) = SetupBaseS(config, pkR, info, randomness)?; let cipher_text = AeadSeal(aead_id, \u0026amp;key, \u0026amp;nonce, aad, payload)?; The receiver gets cipher_text and enc that it can use to retrieve the payload.\nlet (key, nonce, _, _) = SetupBaseR(config, enc, skR, info)?; let payload = AeadOpen(aead, \u0026amp;key, \u0026amp;nonce, aad, ct)?; In the remainder of this blog post we\u0026rsquo;ll show how SetupBaseS is defined. For a description of the receiver please check out the documentation. We will not define AeadSeal and AeadOpen here as they follow the definition of RFC 5116.\nüí° Background on hacspec Syntax In case you are not familiar with hacspec (Rust) syntax, here are some short explainers to understand the hacspec code. The Question mark ?\nThe question mark ? at the end of most lines in the hacspec code is the way Rust performs error propagation. If the function that is called before the ? does not return an error result, the program continues as expected. But if the function returns an error, the function stops and returns with the error instead.\nThe Result Type\nhacspec (and Rust) uses a Result type such as Result\u0026lt;OkType, ErrorType\u0026gt; to return errors. In hacspec result types are often wrapped into type aliases. For example the SenderContextResult type in the code snippet for SetupBaseS below is a type alias for Result\u0026lt;(Encapsulation, KeySchedule), Error\u0026gt;. If the function is successful and we reach line 10, the function returns success, which is written as SenderContextResult::Ok(...).\nThe Auth Mode In the Auth mode HPKE requires additional input to the Setup functions. The sender needs to provide their private key skS to authenticate themselves. The receiver uses the sender\u0026rsquo;s public key pkS in addition to authenticate the sender. The two functions are defined as follows.\nSetupAuthS(config, pkR:, info, skS, randomness); SetupAuthR(config, enc, skR, info, pkS); Setup In order to set up the KEM and key schedule the sender uses the following SetupBaseS function. Recall that the BaseS refers to the HPKE base mode and sender.\nThe function takes the receiver\u0026rsquo;s public key pkR and context information info (a sequence of bytes to bind the setup to a specific context). In addition we need to pass in the configuration that contains the mode as well as the algorithm identifiers for the KEM. Because hacspec can\u0026rsquo;t draw its own randomness, as explained below, it is passed in as well.\npub fn SetupBaseS( configuration: HPKEConfig, pkR: \u0026amp;HpkePublicKey, info: \u0026amp;Info, randomness: Randomness, ) -\u0026gt; SenderContextResult { let (shared_secret, enc) = Encap(kem(configuration), pkR, randomness)?; let key_schedule = KeySchedule( config, \u0026amp;shared_secret, info, \u0026amp;default_psk(), \u0026amp;default_psk_id(), )?; SenderContextResult::Ok((enc, key_schedule)) } For comparison you can find the RFC pseudocode definition of SetupBaseS below (which is not well defined as is because it is missing the algorithm identifiers). The main difference between the two functions is the explicit configuration and randomness required in hacspec.\ndef SetupBaseS(pkR, info): shared_secret, enc = Encap(pkR) return enc, KeyScheduleS(mode_base, shared_secret, info, default_psk, default_psk_id) The setup function calls the two functions Encap and KeySchedule.\nEncap (Reminder: For demonstration purposes we use the DHKEM defined in the RFC.)\nThe Encap function takes the receiver\u0026rsquo;s public key pkR and generates a shared_secret as well as an encapsulation.\nIt is necessary to pass in the algorithm identifier to know which KEM to use and the randomness to generate a new ephemeral key pair for the KEM. See the discussion section below on the necessity of the API changes. Because the function can fail it returns a result instead of simply the computed values as described in the RFC pseudocode.\ndef Encap(pkR): skE, pkE = GenerateKeyPair() dh = DH(skE, pkR) enc = SerializePublicKey(pkE) pkRm = SerializePublicKey(pkR) kem_context = concat(enc, pkRm) shared_secret = ExtractAndExpand(dh, kem_context) return shared_secret, enc All these changes make it much clearer what can happen within the function and in particular which error states might occur.\nThe Encap function generates a fresh DH key pair and computes the DH between the receivers public key and the ephemeral private key $\\text{dh}=\\text{skE}*\\text{pkR}$. The shared_secret is then computed as the output of a key derivation function (HKDF) on input of the dh value and the context that binds the key derivation to the parameters and public values. The encapsulation enc is the serialized public key pkE generated in the first step.\npub fn Encap(pkR: \u0026amp;PublicKey, alg: KEM, rand: Randomness) -\u0026gt; EncapResult { let (skE, pkE) = GenerateKeyPair(alg, rand)?; let dh = DH(alg, \u0026amp;skE, pkR)?; let encapsulation = SerializePublicKey(alg, \u0026amp;pkE)?; let pkRm = SerializePublicKey(alg, pkR)?; let kem_context = enc.concat(\u0026amp;pkRm); let shared_secret = ExtractAndExpand(alg, \u0026amp;suite_id(alg), dh, kem_context)?; EncapResult::Ok((shared_secret, encapsulation)) } KeySchedule In order to use the shared_secret with an AEAD and allow exporting additional key material, the following KeySchedule derives the key and base_nonce for the AEAD and an exporter_secret to export other keys. The key schedule is essentially a series of HKDF calls to extract different keys from the shared secret.\nThe main difference to the RFC here is again that it is necessary to pass in algorithm identifiers and the suite_id to LabeledExtract and LabeledExpand. The suite_id binds the KDF extract and expand functions to the specific context and is implicit in the RFC.\npub fn KeySchedule( config: HPKEConfig, shared_secret: \u0026amp;SharedSecret, info: \u0026amp;Info, psk: \u0026amp;Psk, psk_id: \u0026amp;PskId, ) -\u0026gt; ContextResult { VerifyPSKInputs(config, psk, psk_id)?; let HPKEConfig(mode, _kem, kdf, aead) = config; let psk_id_hash = LabeledExtract( kdf, \u0026amp;suite_id(config), \u0026amp;empty_bytes(), \u0026amp;psk_id_hash_label(), psk_id, )?; let info_hash = LabeledExtract( kdf, \u0026amp;suite_id(config), \u0026amp;empty_bytes(), \u0026amp;info_hash_label(), info, )?; let key_schedule_context = hpke_mode_label(mode) .concat_owned(psk_id_hash) .concat_owned(info_hash); let secret = LabeledExtract(kdf, \u0026amp;suite_id(config), shared_secret, \u0026amp;secret_label(), psk)?; let key = LabeledExpand( kdf, \u0026amp;suite_id(config), \u0026amp;secret, \u0026amp;key_label(), \u0026amp;key_schedule_context, Nk(aead), )?; let base_nonce = LabeledExpand( kdf, \u0026amp;suite_id(config), \u0026amp;secret, \u0026amp;base_nonce_label(), \u0026amp;key_schedule_context, Nn(aead), )?; let exporter_secret = LabeledExpand( kdf, \u0026amp;suite_id(config), \u0026amp;secret, \u0026amp;exp_label(), \u0026amp;key_schedule_context, Nh(kdf), )?; } For comparison you can find the RFC pseudocode definition of KeySchedule below. Note that the significantly longer hacspec definition above is not in fact longer but has longer lines that are wrapped.\ndef KeySchedule\u0026lt;ROLE\u0026gt;(mode, shared_secret, info, psk, psk_id): VerifyPSKInputs(mode, psk, psk_id) psk_id_hash = LabeledExtract(\u0026#34;\u0026#34;, \u0026#34;psk_id_hash\u0026#34;, psk_id) info_hash = LabeledExtract(\u0026#34;\u0026#34;, \u0026#34;info_hash\u0026#34;, info) key_schedule_context = concat(mode, psk_id_hash, info_hash) secret = LabeledExtract(shared_secret, \u0026#34;secret\u0026#34;, psk) key = LabeledExpand(secret, \u0026#34;key\u0026#34;, key_schedule_context, Nk) base_nonce = LabeledExpand(secret, \u0026#34;base_nonce\u0026#34;, key_schedule_context, Nn) exporter_secret = LabeledExpand(secret, \u0026#34;exp\u0026#34;, key_schedule_context, Nh) return Context\u0026lt;ROLE\u0026gt;(key, base_nonce, 0, exporter_secret) This is all that is needed to implement HPKE. All code examples here are taken directly from the Cryspen HPKE reference implementation. You can find the full code in the Github repository as well as the documentation.\nImplementation Considerations When defining HPKE in hacspec, or most other programming languages, there are a number of considerations that impact the way the code looks.\nThe hacspec code is as close to the RFC pseudocode as possible. But some changes are needed.\nRandomness hacspec does not allow to draw randomness. It is therefore necessary to pass in randomness every time it is needed.\nThis approach is pretty close to the way this would be implemented in native Rust where a random-number generator is passed in and used to generate randomness. For simplicity hacspec expects the randomness to be drawn on the outside instead of doing it within the specification.\nNote that it is possible to pre-determine the amount of randomness needed by HPKE calls because randomness is only needed when setting up the sender. At this point the KEM mechanisms and hence the required randomness is known.\nConfiguration Parameters The HPKE RFC makes most of the configuration implicit to the functions rather than passing the algorithm identifiers around. Because the hacspec implementation has to know which algorithm to pick, this is of course not possible here.\nHPKE hacspec functions take either an HPKEConfig object with all algorithms in it or the specific algorithm identifier needed for the operation.\nNaming The HPKE RFC uses, in some cases, names that are impossible to use in hacspec because they are keywords or contain illegal characters. Further does hacspec not support member functions as defined for the Context.\nWe therefore replace . in member function calls such as Context.Export with an underscore, i.e. write Context_Export. Keywords such as open are replaced with a semantically equivalent version, i.e. HpkeOpen in this example.\nSecret bytes hacspec has the notion of secret integers that can\u0026rsquo;t be used for certain operations and should enforce secret-independent computation time.\nFor simplicity the hacspec HPKE implementation uses secret bytes everywhere even if not necessary, e.g. for cipher texts.\nErrors While the RFC defines a set of errors it does not always define which errors are raised. For example, it leaves open whether implementations convert errors from the Diffie-Hellman operations into KEM errors (EncapError/DecapError) or not.\nWith the specific implementation in hacspec here the errors are clearly defined.\nAbout hacspec hacspec is a specification language for cryptographic mechanisms, and more, embedded in Rust. It is a language for writing succinct, executable, formal specifications for cryptographic components. Syntactically, hacspec is a purely functional subset of Rust that aims to be readable by developers, cryptographers, and verification experts. An application developer can use hacspec to specify and prototype cryptographic components in Rust, and then either replace this specification with a verified implementation before deployment or use the hacspec code directly.\nWe used hacspec here to write an executable, succinct, specification of HPKE that\u0026rsquo;s embedding the full RFC into its documentation\nhacspec is at the heart of a novel, modular verification framework for Rust applications developed by Cryspen in cooperation with the Prosecco team.\nSummary Even though HPKE is a relatively simple scheme it requires care when implementing. This blog post gives an overview of how hacspec can be used to achieve an executable version of the HPKE RFC that can be used as implementation on its own or as specification and reference implementation when implementing HPKE.\nCryspen offers support for using HPKE as well as high assurance implementations of HPKE and other protocols. Get in touch for more information.\nGithub repository Documentation RFC ","date":"24 Feb, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/hpke_spec_hu4cb9b0bb4d1bfca6e45e87162bd8ddf2_355178_545x0_resize_q95_h2_box_3.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/hpke_spec_hu4cb9b0bb4d1bfca6e45e87162bd8ddf2_355178_600x0_resize_q95_h2_box_3.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/hpke_spec_hu4cb9b0bb4d1bfca6e45e87162bd8ddf2_355178_700x0_resize_q95_h2_box_3.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/hpke_spec_hu4cb9b0bb4d1bfca6e45e87162bd8ddf2_355178_1110x0_resize_q95_h2_box_3.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/hpke_spec_hu4cb9b0bb4d1bfca6e45e87162bd8ddf2_355178_1110x0_resize_box_3.png\" alt=\"\" width=\"1229\" height=\"908\"\u003e\n\u003c/picture\u003e\n \n \n \n\n","permalink":"https://blog.cryspen.com/blog/hpke_spec/","tags":["hacspec","HPKE","IETF"],"title":"An Executable HPKE Specification"},{"categories":null,"contents":"HPKE, defined in RFC 9180, is a CFRG standard that describes a scheme for hybrid public key encryption. It is co-authored by my Cryspen co-founder Karthikeyan Bhargavan and one of his PhD students Benjamin Lipp as part of his research at Inria.\nThis blog post will give a brief overview of the specification and describes some use cases.\nIf you want to learn more about the security proofs behind HPKE and the RFC process, Benjamin wrote an excellent blog post about it.\nHybrid Public Key Encryption, or short HPKE, is a cyrptographic mechanism that allows encrypting payload to a public key. It is called \u0026ldquo;hybrid\u0026rdquo; because the payload is encrypted with a symmetric scheme. The symmetric key is then encrypted to the receivers public key. The HPKE standard defines a number of natural extensions to the basic setting that allow the sender to authenticate themselves.\nHybrid Crypto Systems Hybrid public key encryption has been used in different ways since the early 1990s in protocols such as PGP or SMIME. While these two protocols are for a very specific use case a more general version of hybrid encryption is described in ECIES. ECIES is part of many systems nowadays. Storing keys in the secure enclave on an iOS device for example uses ECIES. For a deeper explanation and history of hybrid crypto systems I recommend reading Christopher Wood\u0026rsquo;s blog post.\nHowever, there\u0026rsquo;s no general description of hybrid public key encryption with modern primitives. The HPKE standard solves this issue. Even before the RFC is finalised it is used in specifications for ECH, MLS, ODOH, and PPM. This shows the high demand for HPKE.\nHPKE has four distinct modes of operation: Base, Auth, PSK, AuthPSK. In this blog post we only describe the two most commonly used modes Base and Auth.\nHPKE Modes\nThe Base mode is the most common use case for HPKE where payload is encrypted to a public key. All other modes are authenticated in different ways.\nAuth uses the sender\u0026rsquo;s private key for authentication PSK uses a pre-shared, high-entropy, key for authentication AuthPSK uses the sender\u0026rsquo;s private key as well as a pre-shared, high-entropy, key for authentication Encrypting to a public key The following figure depicts the general flow of encrypting to a public key. This is the Base mode in HPKE. This is the most basic application of hybrid crypto systems. Alex knows the public key from Sasha and wants to send some Data to them. Shasha\u0026rsquo;s public key is used to encrypt a shared secret, which is used to encrypt the Data. The encrypted shared secret as well as the encrypted data is sent to Sasha, who can retrieve the shared secret with their corresponding private key.\nEncrypting to a public key \u0026amp; Authenticating with an asymmetric key Sometimes it is useful or necessary to authenticate the sender of the data. This is depicted in the figure below and represents the HPKE Auth mode. The authentication is achieved by mixing in the sender\u0026rsquo;s private key such that the receiver will only retrieve the correct shared secret if the public key they use for the sender corresponds to the used private key.\nHPKE HPKE is essentially standardising how to use Key Encapsulation Mechanisms (KEM) for hybrid encryption. The sender in HPKE uses a KEM to generate the shared secret as well as the encapsulation. The shared secret is then used in an AEAD (after running it through a key schedule) in order to encrypt a payload.\nAll HPKE use cases so far only take advantage of the single-shot APIs from HPKE. In order to encrypt a payload to a public key the sender needs to provide the receiver\u0026rsquo;s public key pkR, some information info and additional data aad to bind the encryption to a certain context, as well as the payload pt. HPKE returns the cipher text ct as well as the encapsulation enc that are both sent to the receiver.\nenc, ct \u0026lt;- Seal(pkR, info, aad, pt) When using the Auth mode the sender\u0026rsquo;s private key sk is needed in addition.\nThe receiver takes the encapsulation enc and cipher text ct together with their private key to retrieve the payload.\npt \u0026lt;- Open(enc, skR, info, aad, ct) When using the Auth mode the sender\u0026rsquo;s public key pkS is needed in addition.\nMultiple Encryptions HPKE allows multiple encryptions with the same shared secret. This is favourable if multiple messages are sent from the sender to the receiver. To this end HPKE generates a context that allows encrypting (and decrypting) multiple messages.\nenc, ContextS \u0026lt;- SetupS(pkR, info) ContextR \u0026lt;- SetupR(enc, skR, info) Note that HPKE goes a step further than the AEAD RFC and simplifies the API. The consumer only needs to provide the payload and (potentially empty) additional data. HPKE takes care of providing unique nonces to the AEAD and fails if the maximum number of encryptions with the context have been performed \u0026mdash; in particular if the nonce would overflow.\nct \u0026lt;- ContextS.Seal(aad, pt) pt \u0026lt;- ContextR.Open(aad, ct) Exporting Secrets In some scenarios applications need to establish additional shared secrets. This can be achieved with the HPKE exporter interface. The API is similar to the Seal and Open functions above but don\u0026rsquo;t require a payload or additional data. Instead an exporter_context and the length of the exported secret L have to be provided.\nenc, exported_secret \u0026lt;- SendExport(pkR, info, exporter_context, L) exported_secret \u0026lt;- ReceiveExport(enc, skR, info, exporter_context, L) Use Cases Instead of inventing new use cases for HPKE we describe how HPKE is used in MLS and ECH as they reflect common uses of hybrid public key encryption.\nHPKE in MLS MLS (Message Layer Security) is an IETF draft that standardises a new way of efficiently encrypting messages between participants in groups. It aims to solve the problem of end-to-end encryption in instant messaging. HPKE is a core building block. In order to encrypt a message to a specific entity in the protocol, MLS uses HPKE to encrypt the message to the specific public key.\nHPKE in ECH ECH (Encrypted Client Hello) is a mechanism in TLS (Transport Layer Security) for encrypting a ClientHello message under a server public key. This description from the ECH draft corresponds directly to the Base mode of HPKE as described above. This allows TLS connections to become more private because they don\u0026rsquo;t leak information about the connection, in particular the exact server the client wants to connect to.\nDemo In order to better understand the message flow and working of HPKE we put together an interactive demo below to demonstrate how HPKE works.\nFirst generate a key pair for the receiver. Then populate the info, additional data, and payload fields on the sender side. When clicking the \u0026ldquo;HPKE Seal\u0026rdquo; button on the sender the following happens The sender retrieves the public key from the receiver that has been generated in the first step. The sender uses HPKE to encrypt the payload together with the info and additional data to the receiver\u0026rsquo;s public key. The result is written into the Encoded Shared Secret and Ciphertext fields. When clicking \u0026ldquo;HPKE Open\u0026rdquo; the receiver uses the private key to retrieve the shared secret and decrypt the ciphertext. The \u0026ldquo;Info\u0026rdquo; and \u0026ldquo;Additional Data\u0026rdquo; are the same as entered on the sender\u0026rsquo;s side. Try it out now! The demo is written in hacspec (a subset of Rust) with a WASM frontend. Please stay tuned for a follow-up blog post diving into the details of this implementation.\nSummary HPKE is a simple, but very powerful new tool that allows to efficiently solve key distribution problems (see the MLS use case) as well as increase privacy in existing protocols (see the ECH use case).\nCryspen offers support for using HPKE as well as high assurance implementations of HPKE and other protocols. Get in touch for more information.\n","date":"24 Feb, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/tldr-hpke_hu08cb25aae405155d9080e0a0f66756a3_268000_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/tldr-hpke_hu08cb25aae405155d9080e0a0f66756a3_268000_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/tldr-hpke_hu08cb25aae405155d9080e0a0f66756a3_268000_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/tldr-hpke_hu08cb25aae405155d9080e0a0f66756a3_268000_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/tldr-hpke_hu08cb25aae405155d9080e0a0f66756a3_268000_1110x0_resize_q95_box.jpg\" alt=\"\" width=\"2221\" height=\"1293\"\u003e\n\u003c/picture\u003e\n \n \n \n\n","permalink":"https://blog.cryspen.com/blog/tldr-hpke/","tags":["tl;dr","HPKE","IETF"],"title":"TL;DR - Hybrid Public Key Encryption"},{"categories":null,"contents":"Cryspen co-founder Karthik Bhargavan got awarded an ERC Proof of Concept grant for commercialising the know-how and landmark research results from his Inria research group PROSECCO through Cryspen.\nAnnouncement Cryptographic mechanisms are crucial to the security of our digital lives but their design and implementation remains notoriously difficult and error-prone. With the help of two ERC Grants, Karthikeyan Bhargavan and the Prosecco team at Inria have developed state-of-the-art formal verification techniques that can be applied to real-world cryptographic software. In particular, they used these techniques to help design and analyze the TLS 1.3 protocol standard, as well to build the HACL* verified cryptographic library, code from which has been incorporated in mainstream software projects including Mozilla Firefox, the Linux Kernel, the Tezos Blockchain, the WireGuard VPN, and the ElectionGuard voting system.\nThe goal of this new ERC Proof of Concept grant is to build upon these these landmark research results and to commercialise the associated know-how through a new company called Cryspen. Cryspen will build a verified cryptographic software stack and an associated verification toolchain that is well-documented and easy to use for security developers. Cryspen will offer consulting and support contracts for this stack as well as software contracts for developing new cryptographic applications, ranging from secure messaging system to privacy-preserving machine learning.\nCryspen is co-founded by Franziskus Kiefer (CEO), Karthikeyan Bhargavan, and Jonathan Protzenko. For more information, email info@cryspen.com\n","date":"10 Feb, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/erc-cover_hueebb7cb7b7d5f8212f38a9f8abb74d19_57629_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/erc-cover_hueebb7cb7b7d5f8212f38a9f8abb74d19_57629_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/erc-cover_hueebb7cb7b7d5f8212f38a9f8abb74d19_57629_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/erc-cover_hueebb7cb7b7d5f8212f38a9f8abb74d19_57629_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/erc-cover_hueebb7cb7b7d5f8212f38a9f8abb74d19_57629_1110x0_resize_q95_box.jpg\" alt=\"\" width=\"1200\" height=\"849\"\u003e\n\u003c/picture\u003e\n \n \n \n\n","permalink":"https://blog.cryspen.com/blog/erc-poc/","tags":["ERC","grant"],"title":"Cryspen ERC PoC Grant"}]